package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.42

import (
	"context"
	"dto"
	"encoding/json"
	ex "exception"
	"fmt"
	"mail"
	mw "middleware"
	"model"
	"os"
	"reflect"
	"strings"

	"github.com/google/uuid"
	"github.com/lucsky/cuid"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

func (r *mutationResolver) UpdateUserSessions(ctx context.Context, currentSession string, sessionType model.ReqType) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: UpdateUserSessions - updateUserSessions"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	switch sessionType {
	case model.REST:
		user.CurrentRESTSession = &currentSession
	case model.GQL:
		user.CurrentGQLSession = &currentSession
	}
	if err := r.DB.Save(user).Error; err != nil {
		return nil, err
	}
	err := GetPreloadedDB(r.DB, ctx).First(user, `uid=?`, user.UID).Error
	return user, err
}

func (r *mutationResolver) DeleteUser(ctx context.Context) (bool, error) {
	// panic(fmt.Errorf("not implemented: DeleteUser - deleteUser"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return false, ex.ErrBugAuthNoUserCtx
	}
	if err := r.DB.Delete(user).Error; err != nil {
		return false, ex.ErrUserDeletionFailed
	}
	UserDeletedSub.Publish(user)
	return true, nil
}

func (r *mutationResolver) UpdateInfraConfigs(ctx context.Context, infraConfigs []*dto.InfraConfigArgs) (c []*model.InfraConfig, err error) {
	// panic(fmt.Errorf("not implemented: UpdateInfraConfigs - updateInfraConfigs"))
	tx := r.DB.Begin()
	for _, cf := range infraConfigs {
		cfg := &model.InfraConfig{}
		err = tx.Model(cfg).Clauses(clause.Returning{}).Where("name=?", cf.Name).Update("Value", cf.Value).Error
		if err != nil {
			tx.Rollback()
			return
		} else {
			c = append(c, cfg)
		}
	}
	tx.Commit()
	return
}

func (r *mutationResolver) ResetInfraConfigs(ctx context.Context) (bool, error) {
	panic(fmt.Errorf("not implemented: ResetInfraConfigs - resetInfraConfigs"))
}

func (r *mutationResolver) EnableAndDisableSso(ctx context.Context, providerInfo []*dto.EnableAndDisableSSOArgs) (bool, error) {
	panic(fmt.Errorf("not implemented: EnableAndDisableSso - enableAndDisableSSO"))
}

func (r *mutationResolver) InviteNewUser(ctx context.Context, inviteeEmail string) (*model.InvitedUser, error) {
	// panic(fmt.Errorf("not implemented: InviteNewUser - inviteNewUser"))
	admin, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	iu := &model.InvitedUser{
		AdminUID:     admin.UID,
		AdminEmail:   *admin.Email,
		InviteeEmail: inviteeEmail,
		Admin:        *admin,
	}
	tx := r.DB.Begin()
	if err := tx.Save(iu).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	magicLink := os.Getenv("VITE_BASE_URL")
	if err := mail.SendUserInvitation(inviteeEmail, magicLink); err != nil {
		tx.Rollback()
		return nil, err
	}
	tx.Commit()
	UserInvitedSub.Publish(iu)
	return iu, nil
}

func (r *mutationResolver) RemoveUserByAdmin(ctx context.Context, userUID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: RemoveUserByAdmin - removeUserByAdmin"))
	user := &model.User{}
	if err := r.DB.First(user, "uid=?", userUID).Error; err != nil {
		return false, ex.ErrUserNotFound
	}
	if err := r.DB.Delete(user).Error; err != nil {
		return false, ex.ErrUserDeletionFailed
	}
	UserDeletedSub.Publish(user)
	return true, nil
}

func (r *mutationResolver) MakeUserAdmin(ctx context.Context, userUID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: MakeUserAdmin - makeUserAdmin"))
	err := r.DB.Model(&model.User{}).Where("uid=?", userUID).Update("isAdmin", true).Error
	return err == nil, err
}

func (r *mutationResolver) RemoveUserAsAdmin(ctx context.Context, userUID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: RemoveUserAsAdmin - removeUserAsAdmin"))
	err := r.DB.Model(&model.User{}).Where("uid=?", userUID).Update("isAdmin", false).Error
	return err == nil, err
}

func (r *mutationResolver) CreateTeamByAdmin(ctx context.Context, userUID string, name string) (*model.Team, error) {
	// panic(fmt.Errorf("not implemented: CreateTeamByAdmin - createTeamByAdmin"))
	teamID := cuid.New()
	member := &model.TeamMember{
		ID:      uuid.NewString(),
		TeamID:  teamID,
		UserUID: userUID,
		Role:    model.OWNER,
	}
	team := &model.Team{
		ID:          teamID,
		Name:        name,
		Teammembers: []model.TeamMember{*member},
	}
	if err := r.DB.Create(team).Error; err != nil {
		return nil, err
	}
	// TeamMemberAddedSub.Publish(member)
	return team, nil
}

func (r *mutationResolver) ChangeUserRoleInTeamByAdmin(ctx context.Context, userUID string, teamID string, newRole model.TeamMemberRole) (*model.TeamMember, error) {
	// panic(fmt.Errorf("not implemented: ChangeUserRoleInTeamByAdmin - changeUserRoleInTeamByAdmin"))
	member := &model.TeamMember{}
	if err := GetPreloadedDB(r.DB, ctx).Where(`"userUid"=? AND "teamID"=?`, userUID, teamID).First(member).Error; err != nil {
		return nil, err
	}
	if err := r.DB.Model(member).Clauses(clause.Returning{}).Where(
		`"userUid"=? AND "teamID"=?`, userUID, teamID,
	).Update(
		"role", model.TeamMemberRole(newRole),
	).Error; err != nil {
		return nil, err
	}
	TeamMemberUpdatedSub.Publish(member)
	return member, nil
}

func (r *mutationResolver) RemoveUserFromTeamByAdmin(ctx context.Context, userUID string, teamID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: RemoveUserFromTeamByAdmin - removeUserFromTeamByAdmin"))
	member := &model.TeamMember{}
	if err := r.DB.Model(member).Clauses(clause.Returning{}).Where(`"userUid"=? AND "teamID"=?`, userUID, teamID).Delete(member).Error; err != nil {
		return false, err
	}
	TeamMemberRemovedSub.Publish(member.ID)
	return true, nil
}

func (r *mutationResolver) AddUserToTeamByAdmin(ctx context.Context, teamID string, role model.TeamMemberRole, userEmail string) (*model.TeamMember, error) {
	// panic(fmt.Errorf("not implemented: AddUserToTeamByAdmin - addUserToTeamByAdmin"))
	user := &model.User{}
	if err := r.DB.Model(&model.User{}).Find("email=?", userEmail).First(user).Error; err != nil {
		return nil, ex.ErrUserNotFound
	}
	member := &model.TeamMember{}
	if err := r.DB.First(member, `"userUid"=? AND "teamID"=?`, user.UID, teamID).Error; err != nil {
		return nil, err
	}
	if member.UserUID != "" {
		return nil, ex.ErrTeamInviteAlreadyMember
	}
	member.ID = uuid.NewString()
	member.UserUID = user.UID
	member.TeamID = teamID
	member.User = *user
	if err := r.DB.Create(member).Error; err != nil {
		return nil, err
	}
	TeamMemberAddedSub.Publish(member)
	return member, nil
}

func (r *mutationResolver) RenameTeamByAdmin(ctx context.Context, teamID string, newName string) (*model.Team, error) {
	// panic(fmt.Errorf("not implemented: RenameTeamByAdmin - renameTeamByAdmin"))
	team := &model.Team{}
	if err := GetPreloadedDB(r.DB, ctx).First(team, "id=?", teamID).Error; err != nil {
		return nil, err
	}
	err := r.DB.Model(team).Clauses(clause.Returning{}).Where("id=?", teamID).Update("name", newName).Error
	return team, err
}

func (r *mutationResolver) DeleteTeamByAdmin(ctx context.Context, teamID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: DeleteTeamByAdmin - deleteTeamByAdmin"))
	err := r.DB.Delete(&model.Team{}, "id=?", teamID).Error
	return err == nil, nil
}

func (r *mutationResolver) RevokeTeamInviteByAdmin(ctx context.Context, inviteID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: RevokeTeamInviteByAdmin - revokeTeamInviteByAdmin"))
	if err := r.DB.Delete(&model.TeamInvitation{}, "id=?", inviteID).Error; err != nil {
		return false, err
	}
	TeamInvitationRemovedSub.Publish(inviteID)
	return true, nil
}

func (r *mutationResolver) RevokeShortcodeByAdmin(ctx context.Context, code string) (bool, error) {
	// panic(fmt.Errorf("not implemented: RevokeShortcodeByAdmin - revokeShortcodeByAdmin"))
	sc := &model.Shortcode{}
	if err := r.DB.Model(sc).Clauses(clause.Returning{}).Delete(sc, "id=?", code).Error; err != nil {
		return false, err
	}
	MyShortcodesRevokedSub.Publish(sc)
	return true, nil
}

func (r *mutationResolver) CreateTeam(ctx context.Context, name string) (*model.Team, error) {
	// panic(fmt.Errorf("not implemented: CreateTeam - createTeam"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	team, err := createTeam(r.DB, name, user.UID)
	if err != nil {
		return nil, err
	}
	TeamMemberAddedSub.Publish(&team.Teammembers[0])
	return team, nil
}

func (r *mutationResolver) LeaveTeam(ctx context.Context, teamID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: LeaveTeam - leaveTeam"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return false, ex.ErrBugAuthNoUserCtx
	}
	uid, err := removeTeamMember(r.DB, teamID, user.UID)
	if err != nil {
		return false, err
	}
	TeamMemberRemovedSub.Publish(uid)
	return true, nil
}

func (r *mutationResolver) RemoveTeamMember(ctx context.Context, teamID string, userUID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: RemoveTeamMember - removeTeamMember"))
	uid, err := removeTeamMember(r.DB, teamID, userUID)
	if err != nil {
		return false, err
	}
	TeamMemberRemovedSub.Publish(uid)
	return true, nil
}

func (r *mutationResolver) RenameTeam(ctx context.Context, teamID string, newName string) (*model.Team, error) {
	// panic(fmt.Errorf("not implemented: RenameTeam - renameTeam"))
	team := &model.Team{}
	if err := GetPreloadedDB(r.DB, ctx).First(team, "id=?", teamID).Error; err != nil {
		return nil, err
	}
	err := r.DB.Model(team).Clauses(clause.Returning{}).Where("id=?", teamID).Update("name", newName).Error
	return team, err
}

func (r *mutationResolver) DeleteTeam(ctx context.Context, teamID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: DeleteTeam - deleteTeam"))
	team := &model.Team{}
	err := r.DB.Delete(team, "id=?", teamID).Error
	return err == nil, err
}

func (r *mutationResolver) UpdateTeamMemberRole(ctx context.Context, teamID string, userUID string, newRole model.TeamMemberRole) (*model.TeamMember, error) {
	// panic(fmt.Errorf("not implemented: UpdateTeamMemberRole - updateTeamMemberRole"))
	teamMember := &model.TeamMember{}
	if err := GetPreloadedDB(r.DB, ctx).First(teamMember, `"teamID" = ? AND "userUid" = ?`, teamID, userUID).Error; err != nil {
		return nil, err
	}
	teamMember.Role = newRole
	if err := r.DB.Save(teamMember).Error; err != nil {
		return nil, err
	}
	TeamMemberUpdatedSub.Publish(teamMember)
	return teamMember, nil
}

func (r *mutationResolver) CreateTeamInvitation(ctx context.Context, teamID string, inviteeEmail string, inviteeRole model.TeamMemberRole) (*model.TeamInvitation, error) {
	// panic(fmt.Errorf("not implemented: CreateTeamInvitation - createTeamInvitation"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	team := &model.Team{}
	if err := r.DB.First(team, "id=?", teamID).Error; err != nil {
		return nil, err
	}
	invite := &model.TeamInvitation{
		ID:           cuid.New(),
		TeamID:       teamID,
		InviteeEmail: inviteeEmail,
		InviteeRole:  inviteeRole,
		CreatorUID:   user.UID,
	}
	tx := r.DB.Begin()
	if err := tx.Create(invite).Error; err != nil {
		tx.Rollback()
		return nil, err
	}
	base_url := os.Getenv("VITE_BASE_URL")
	url := fmt.Sprintf("%s/join-team?id=%s", base_url, invite.ID)
	if err := mail.SendTeamInvitation(inviteeEmail, *user.DisplayName, team.Name, url); err != nil {
		tx.Rollback()
		return nil, err
	}
	tx.Commit()
	if err := GetPreloadedDB(r.DB, ctx).First(invite, "id=?", invite.ID).Error; err != nil {
		return nil, err
	}
	TeamInvitationAddedSub.Publish(invite)
	return invite, nil
}

func (r *mutationResolver) RevokeTeamInvitation(ctx context.Context, inviteID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: RevokeTeamInvitation - revokeTeamInvitation"))
	if err := r.DB.Delete(&model.TeamInvitation{}, "id=?", inviteID).Error; err != nil {
		return false, err
	}
	TeamInvitationRemovedSub.Publish(inviteID)
	return true, nil
}

func (r *mutationResolver) AcceptTeamInvitation(ctx context.Context, inviteID string) (*model.TeamMember, error) {
	// panic(fmt.Errorf("not implemented: AcceptTeamInvitation - acceptTeamInvitation"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	invite := &model.TeamInvitation{}
	if err := r.DB.First(invite, "id=?", inviteID).Error; err != nil {
		return nil, err
	}
	member := &model.TeamMember{
		ID:      cuid.New(),
		TeamID:  invite.TeamID,
		UserUID: user.UID,
		Role:    invite.InviteeRole,
	}
	if err := r.DB.Create(member).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(member, "id=?", member.ID).Error; err != nil {
		return nil, err
	}
	TeamMemberAddedSub.Publish(member)
	return member, nil
}

func (r *mutationResolver) CreateTeamEnvironment(ctx context.Context, name string, teamID string, variables string) (*model.TeamEnvironment, error) {
	// panic(fmt.Errorf("not implemented: CreateTeamEnvironment - createTeamEnvironment"))
	env := &model.TeamEnvironment{
		ID:        cuid.New(),
		TeamID:    teamID,
		Name:      name,
		Variables: variables,
	}
	if err := r.DB.Create(env).Error; err != nil {
		return nil, err
	}
	team := &model.Team{}
	if err := GetPreloadedDB(r.DB, ctx).First(team, "id=?", teamID).Error; err != nil {
		return nil, err
	}
	TeamEnvironmentCreatedSub.Publish(env)
	return env, nil
}

func (r *mutationResolver) DeleteTeamEnvironment(ctx context.Context, id string) (bool, error) {
	// panic(fmt.Errorf("not implemented: DeleteTeamEnvironment - deleteTeamEnvironment"))
	env := &model.TeamEnvironment{}
	if err := r.DB.First(env, "id=?", id).Error; err != nil {
		return false, err
	}
	if err := r.DB.Delete(env).Error; err != nil {
		return false, err
	}
	TeamEnvironmentDeletedSub.Publish(env)
	return true, nil
}

func (r *mutationResolver) UpdateTeamEnvironment(ctx context.Context, id string, name string, variables string) (*model.TeamEnvironment, error) {
	// panic(fmt.Errorf("not implemented: UpdateTeamEnvironment - updateTeamEnvironment"))
	env := &model.TeamEnvironment{}
	if err := GetPreloadedDB(r.DB, ctx).First(env, "id=?", id).Error; err != nil {
		return nil, err
	}
	env.Name = name
	env.Variables = variables
	if err := r.DB.Save(env).Error; err != nil {
		return nil, err
	}
	TeamEnvironmentUpdatedSub.Publish(env)
	return env, nil
}

func (r *mutationResolver) DeleteAllVariablesFromTeamEnvironment(ctx context.Context, id string) (*model.TeamEnvironment, error) {
	// panic(fmt.Errorf("not implemented: DeleteAllVariablesFromTeamEnvironment - deleteAllVariablesFromTeamEnvironment"))
	env := &model.TeamEnvironment{}
	if err := GetPreloadedDB(r.DB, ctx).First(env, "id=?", id).Error; err != nil {
		return nil, err
	}
	env.Variables = ""
	if err := r.DB.Save(env).Error; err != nil {
		return nil, err
	}
	TeamEnvironmentUpdatedSub.Publish(env)
	return env, nil
}

func (r *mutationResolver) CreateDuplicateEnvironment(ctx context.Context, id string) (*model.TeamEnvironment, error) {
	// panic(fmt.Errorf("not implemented: CreateDuplicateEnvironment - createDuplicateEnvironment"))
	env := &model.TeamEnvironment{}
	if err := r.DB.First(env, "id=?", id).Error; err != nil {
		return nil, err
	}
	dupEnv := &model.TeamEnvironment{
		ID:        cuid.New(),
		TeamID:    env.TeamID,
		Name:      env.Name + " Copy",
		Variables: env.Variables,
	}
	if err := r.DB.Create(dupEnv).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(dupEnv, "id=?", dupEnv.ID).Error; err != nil {
		return nil, err
	}
	TeamEnvironmentCreatedSub.Publish(dupEnv)
	return dupEnv, nil
}

func (r *mutationResolver) CreateRootCollection(ctx context.Context, teamID string, title string, data *string) (*model.TeamCollection, error) {
	// panic(fmt.Errorf("not implemented: CreateRootCollection - createRootCollection"))
	coll := &model.TeamCollection{
		ID:         cuid.New(),
		TeamID:     teamID,
		Title:      title,
		OrderIndex: getTeamMaxOrderIndex(r.DB, &model.TeamCollection{}, &teamID, nil) + 1,
	}
	if err := r.DB.Create(coll).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(coll, "id=?", coll.ID).Error; err != nil {
		return nil, err
	}
	TeamCollectionAddedSub.Publish(coll)
	return coll, nil
}

func (r *mutationResolver) ImportCollectionsFromJSON(ctx context.Context, teamID string, jsonString string, parentCollectionID *string) (bool, error) {
	panic(fmt.Errorf("not implemented: ImportCollectionsFromJSON - importCollectionsFromJSON"))
}

func (r *mutationResolver) ReplaceCollectionsWithJSON(ctx context.Context, teamID string, jsonString string, parentCollectionID *string) (bool, error) {
	panic(fmt.Errorf("not implemented: ReplaceCollectionsWithJSON - replaceCollectionsWithJSON"))
}

func (r *mutationResolver) CreateChildCollection(ctx context.Context, collectionID string, childTitle string, data *string) (*model.TeamCollection, error) {
	// panic(fmt.Errorf("not implemented: CreateChildCollection - createChildCollection"))
	coll := &model.TeamCollection{}
	if err := r.DB.First(coll, "id=?", collectionID).Error; err != nil {
		return nil, err
	}
	child, err := createChildTeamCollection(r.DB, childTitle, data, *coll)
	if err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(child, "id=?", child.ID).Error; err != nil {
		return nil, err
	}
	TeamCollectionAddedSub.Publish(child)
	return child, err
}

func (r *mutationResolver) RenameCollection(ctx context.Context, collectionID string, newTitle string) (*model.TeamCollection, error) {
	// panic(fmt.Errorf("not implemented: RenameCollection - renameCollection"))
	coll := &model.TeamCollection{}
	if err := GetPreloadedDB(r.DB, ctx).First(coll, "id=?", collectionID).Error; err != nil {
		return nil, err
	}
	coll.Title = newTitle
	if err := r.DB.Save(coll).Error; err != nil {
		return nil, err
	}
	TeamCollectionUpdatedSub.Publish(coll)
	return coll, nil
}

func (r *mutationResolver) DeleteCollection(ctx context.Context, collectionID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: DeleteCollection - deleteCollection"))
	if err := r.DB.Delete(&model.TeamCollection{}, "id=?", collectionID).Error; err != nil {
		return false, err
	}
	TeamCollectionRemovedSub.Publish(collectionID)
	return true, nil
}

func (r *mutationResolver) MoveCollection(ctx context.Context, parentCollectionID *string, collectionID string) (*model.TeamCollection, error) {
	// panic(fmt.Errorf("not implemented: MoveCollection - moveCollection"))
	coll := &model.TeamCollection{}
	if err := r.DB.First(coll, "id=?", collectionID).Error; err != nil {
		return nil, err
	}
	if err := moveTeamCollection(r.DB, coll, parentCollectionID); err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(coll, "id=?", coll.ID).Error; err != nil {
		return nil, err
	}
	TeamCollectionMovedSub.Publish(coll)
	return coll, nil
}

func (r *mutationResolver) UpdateCollectionOrder(ctx context.Context, collectionID string, destCollID *string) (bool, error) {
	// panic(fmt.Errorf("not implemented: UpdateCollectionOrder - updateCollectionOrder"))
	coll := &model.TeamCollection{}
	if err := r.DB.First(coll, "id=?", collectionID).Error; err != nil {
		return false, err
	}
	destColl := &model.TeamCollection{}
	if destCollID != nil {
		if err := r.DB.First(destColl, "id=?", *destCollID).Error; err != nil {
			return false, err
		}
	}
	if dto, err := updateTeamCollectionOrder(r.DB, coll, destColl); err != nil {
		return false, err
	} else {
		CollectionOrderUpdatedSub.Publish(dto)
	}
	return true, nil
}

func (r *mutationResolver) UpdateTeamCollection(ctx context.Context, collectionID string, newTitle *string, data *string) (*model.TeamCollection, error) {
	// panic(fmt.Errorf("not implemented: UpdateTeamCollection - updateTeamCollection"))
	coll := &model.TeamCollection{}
	if err := GetPreloadedDB(r.DB, ctx).First(coll, "id=?", collectionID).Error; err != nil {
		return nil, err
	}
	if newTitle != nil {
		coll.Title = *newTitle
	}
	if data != nil {
		coll.Data = data
	}
	if err := r.DB.Save(coll).Error; err != nil {
		return nil, err
	}
	TeamCollectionUpdatedSub.Publish(coll)
	return coll, nil
}

func (r *mutationResolver) CreateRequestInCollection(ctx context.Context, collectionID string, data dto.CreateTeamRequestInput) (*model.TeamRequest, error) {
	// panic(fmt.Errorf("not implemented: CreateRequestInCollection - createRequestInCollection"))
	coll := &model.TeamCollection{}
	if err := r.DB.First(coll, "id=?", collectionID).Error; err != nil {
		return nil, err
	}
	detail := model.ReqDetail{}
	if err := json.Unmarshal([]byte(data.Request), &detail); err != nil {
		return nil, err
	}
	req := &model.TeamRequest{
		ID:           cuid.New(),
		CollectionID: coll.ID,
		TeamID:       coll.TeamID,
		Title:        data.Title,
		Request:      detail,
		OrderIndex:   getTeamMaxOrderIndex(r.DB, &model.TeamRequest{}, &coll.TeamID, &coll.ID),
	}
	if err := r.DB.Create(req).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(req, "id=?", req.ID).Error; err != nil {
		return nil, err
	}
	TeamRequestAddedSub.Publish(req)
	return req, nil
}

func (r *mutationResolver) UpdateRequest(ctx context.Context, requestID string, data dto.UpdateTeamRequestInput) (*model.TeamRequest, error) {
	// panic(fmt.Errorf("not implemented: UpdateRequest - updateRequest"))
	req := &model.TeamRequest{}
	if err := GetPreloadedDB(r.DB, ctx).First(req, "id=?", requestID).Error; err != nil {
		return nil, err
	}
	if data.Title != nil {
		req.Title = *data.Title
	}
	if data.Request != nil {
		detail := model.ReqDetail{}
		if err := json.Unmarshal([]byte(*data.Request), &detail); err != nil {
			return nil, err
		}
		req.Request = detail
	}
	if err := r.DB.Save(req).Error; err != nil {
		return nil, err
	}
	TeamRequestUpdatedSub.Publish(req)
	return req, nil
}

func (r *mutationResolver) DeleteRequest(ctx context.Context, requestID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: DeleteRequest - deleteRequest"))
	if err := r.DB.Delete(&model.TeamRequest{}, "id=?", requestID).Error; err != nil {
		return false, err
	}
	TeamRequestDeletedSub.Publish(requestID)
	return true, nil
}

func (r *mutationResolver) UpdateLookUpRequestOrder(ctx context.Context, collectionID string, nextRequestID *string, requestID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: UpdateLookUpRequestOrder - updateLookUpRequestOrder"))
	req := &model.TeamRequest{}
	if err := r.DB.First(req, "id=?", requestID).Error; err != nil {
		return false, err
	}
	var destReq *model.TeamRequest
	if nextRequestID != nil {
		if err := r.DB.First(destReq, "id=?", nextRequestID).Error; err != nil {
			return false, err
		}
	}
	dto, err := updateTeamRequestOrder(r.DB, req, destReq)
	if err != nil {
		return false, err
	}
	RequestOrderUpdatedSub.Publish(dto)
	return true, nil
}

func (r *mutationResolver) MoveRequest(ctx context.Context, srcCollID *string, requestID string, destCollID string, nextRequestID *string) (*model.TeamRequest, error) {
	// panic(fmt.Errorf("not implemented: MoveRequest - moveRequest"))
	req := &model.TeamRequest{}
	if err := r.DB.First(req, "id=?", requestID).Error; err != nil {
		return nil, err
	}
	if err := moveTeamRequest(r.DB, req, destCollID); err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(req, "id=?", req.ID).Error; err != nil {
		return nil, err
	}
	RequestMovedSub.Publish(req)
	return req, nil
}

func (r *mutationResolver) CreateShortcode(ctx context.Context, request string, properties *string) (*model.Shortcode, error) {
	// panic(fmt.Errorf("not implemented: CreateShortcode - createShortcode"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	shortcode := &model.Shortcode{
		ID:              cuid.New(),
		Request:         request,
		EmbedProperties: properties,
		CreatorUID:      &user.UID,
	}
	if err := r.DB.Create(shortcode).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(shortcode, "id=?", shortcode.ID).Error; err != nil {
		return nil, err
	}
	MyShortcodesCreatedSub.Publish(shortcode)
	return shortcode, nil
}

func (r *mutationResolver) UpdateEmbedProperties(ctx context.Context, code string, properties string) (*model.Shortcode, error) {
	// panic(fmt.Errorf("not implemented: UpdateEmbedProperties - updateEmbedProperties"))
	shortcode := &model.Shortcode{}
	if err := GetPreloadedDB(r.DB, ctx).First(shortcode, "id=?", code).Error; err != nil {
		return nil, err
	}
	shortcode.EmbedProperties = &properties
	if err := r.DB.Save(shortcode).Error; err != nil {
		return nil, err
	}
	MyShortcodesUpdatedSub.Publish(shortcode)
	return shortcode, nil
}

func (r *mutationResolver) RevokeShortcode(ctx context.Context, code string) (bool, error) {
	// panic(fmt.Errorf("not implemented: RevokeShortcode - revokeShortcode"))
	shortcode := &model.Shortcode{}
	if err := r.DB.First(shortcode, "id=?", code).Error; err != nil {
		return false, err
	}
	if err := r.DB.Delete(shortcode).Error; err != nil {
		return false, err
	}
	MyShortcodesRevokedSub.Publish(shortcode)
	return true, nil
}

func (r *mutationResolver) CreateUserSettings(ctx context.Context, properties string) (*model.UserSetting, error) {
	// panic(fmt.Errorf("not implemented: CreateUserSettings - createUserSettings"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	setting := &model.UserSetting{
		ID:         cuid.New(),
		UserUID:    user.UID,
		Properties: properties,
	}
	if err := r.DB.Create(setting).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(setting, "id=?", setting.ID).Error; err != nil {
		return nil, err
	}
	UserSettingsCreatedSub.Publish(setting)
	return setting, nil
}

func (r *mutationResolver) UpdateUserSettings(ctx context.Context, properties string) (*model.UserSetting, error) {
	// panic(fmt.Errorf("not implemented: UpdateUserSettings - updateUserSettings"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	setting := &model.UserSetting{}
	if err := GetPreloadedDB(r.DB, ctx).First(setting, `"userUid" = ?`, user.UID).Error; err != nil {
		return nil, err
	}
	setting.Properties = properties
	if err := r.DB.Save(setting).Error; err != nil {
		return nil, err
	}
	UserSettingsUpdatedSub.Publish(setting)
	return setting, nil
}

func (r *mutationResolver) CreateUserEnvironment(ctx context.Context, name string, variables string) (*model.UserEnvironment, error) {
	// panic(fmt.Errorf("not implemented: CreateUserEnvironment - createUserEnvironment"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	env := &model.UserEnvironment{
		ID:        cuid.New(),
		UserUID:   user.UID,
		Name:      &name,
		Variables: variables,
		IsGlobal:  false,
	}
	if err := r.DB.Create(env).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(env, "id=?", env.ID).Error; err != nil {
		return nil, err
	}
	UserEnvironmentCreatedSub.Publish(env)
	return env, nil
}

func (r *mutationResolver) CreateUserGlobalEnvironment(ctx context.Context, variables string) (*model.UserEnvironment, error) {
	// panic(fmt.Errorf("not implemented: CreateUserGlobalEnvironment - createUserGlobalEnvironment"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	env := &model.UserEnvironment{
		ID:        cuid.New(),
		UserUID:   user.UID,
		Name:      nil,
		Variables: variables,
		IsGlobal:  true,
	}
	if err := r.DB.Create(env).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(env, "id=?", env.ID).Error; err != nil {
		return nil, err
	}
	UserEnvironmentCreatedSub.Publish(env)
	return env, nil
}

func (r *mutationResolver) UpdateUserEnvironment(ctx context.Context, id string, name string, variables string) (*model.UserEnvironment, error) {
	// panic(fmt.Errorf("not implemented: UpdateUserEnvironment - updateUserEnvironment"))
	env := &model.UserEnvironment{}
	if err := GetPreloadedDB(r.DB, ctx).First(env, "id=?", env.ID).Error; err != nil {
		return nil, err
	}
	env.Name = &name
	env.Variables = variables
	if err := r.DB.Save(env).Error; err != nil {
		return nil, err
	}
	UserEnvironmentUpdatedSub.Publish(env)
	return env, nil
}

func (r *mutationResolver) DeleteUserEnvironment(ctx context.Context, id string) (bool, error) {
	// panic(fmt.Errorf("not implemented: DeleteUserEnvironment - deleteUserEnvironment"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return false, ex.ErrBugAuthNoUserCtx
	}
	env := &model.UserEnvironment{}
	if err := r.DB.Where(`id = ? AND "userUid" = ?`, id, user.UID).First(env).Error; err != nil {
		return false, err
	}
	if err := r.DB.Delete(env).Error; err != nil {
		return false, err
	}
	UserEnvironmentDeletedSub.Publish(env)
	return true, nil
}

func (r *mutationResolver) DeleteUserEnvironments(ctx context.Context) (int, error) {
	// panic(fmt.Errorf("not implemented: DeleteUserEnvironments - deleteUserEnvironments"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return 0, ex.ErrBugAuthNoUserCtx
	}
	result := r.DB.Delete(&model.UserEnvironment{}, `"userUid" = ?`, user.UID)
	count := int(result.RowsAffected)
	if result.Error == nil {
		UserEnvironmentDeleteManySub.Publish(count)
	}
	return count, result.Error
}

func (r *mutationResolver) ClearGlobalEnvironments(ctx context.Context, id string) (*model.UserEnvironment, error) {
	// panic(fmt.Errorf("not implemented: ClearGlobalEnvironments - clearGlobalEnvironments"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	env := &model.UserEnvironment{}
	if err := GetPreloadedDB(r.DB, ctx).First(env, `id = ? AND "userUid" = ?`, id, user.UID).Error; err != nil {
		return nil, err
	}
	env.Variables = ""
	if err := r.DB.Save(env).Error; err != nil {
		return nil, err
	}
	UserEnvironmentUpdatedSub.Publish(env)
	return env, nil
}

func (r *mutationResolver) CreateUserHistory(ctx context.Context, reqData string, resMetadata string, reqType model.ReqType) (*model.UserHistory, error) {
	// panic(fmt.Errorf("not implemented: CreateUserHistory - createUserHistory"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	history := &model.UserHistory{
		ID:               cuid.New(),
		UserUID:          user.UID,
		ReqType:          reqType,
		Request:          reqData,
		ResponseMetadata: resMetadata,
		IsStarred:        false,
	}
	if err := r.DB.Create(history).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(history, "id=?", history.ID).Error; err != nil {
		return nil, err
	}
	UserHistoryCreatedSub.Publish(history)
	return history, nil
}

func (r *mutationResolver) ToggleHistoryStarStatus(ctx context.Context, id string) (*model.UserHistory, error) {
	// panic(fmt.Errorf("not implemented: ToggleHistoryStarStatus - toggleHistoryStarStatus"))
	history := &model.UserHistory{}
	if err := GetPreloadedDB(r.DB, ctx).First(history, "id=?", history.ID).Error; err != nil {
		return nil, err
	}
	history.IsStarred = !history.IsStarred
	if err := r.DB.Save(history).Error; err != nil {
		return nil, err
	}
	UserHistoryCreatedSub.Publish(history)
	return history, nil
}

func (r *mutationResolver) RemoveRequestFromHistory(ctx context.Context, id string) (*model.UserHistory, error) {
	// panic(fmt.Errorf("not implemented: RemoveRequestFromHistory - removeRequestFromHistory"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	history := &model.UserHistory{}
	if err := GetPreloadedDB(r.DB, ctx).Where(`id = ? AND "userUid" = ?`, id, user.UID).First(history).Error; err != nil {
		return nil, err
	}
	if err := r.DB.Delete(history).Error; err != nil {
		return nil, err
	}
	UserHistoryDeletedSub.Publish(history)
	return history, nil
}

func (r *mutationResolver) DeleteAllUserHistory(ctx context.Context, reqType model.ReqType) (*dto.UserHistoryDeletedManyData, error) {
	// panic(fmt.Errorf("not implemented: DeleteAllUserHistory - deleteAllUserHistory"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	result := r.DB.Delete(&model.UserHistory{}, `"userUid" = ? AND "reqType" = ?`, user.UID, reqType)
	if result.Error != nil {
		return nil, result.Error
	}
	dto := dto.UserHistoryDeletedManyData{
		Count:   int(result.RowsAffected),
		ReqType: reqType,
	}
	UserHistoryDeletedManySub.Publish(&dto)
	return &dto, nil
}

func (r *mutationResolver) CreateRESTUserRequest(ctx context.Context, collectionID string, title string, request string) (*model.UserRequest, error) {
	// panic(fmt.Errorf("not implemented: CreateRESTUserRequest - createRESTUserRequest"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	latest := getUserMaxOrderIndex(r.DB, &model.UserRequest{}, user.UID, &collectionID)
	detail := model.ReqDetail{}
	if err := json.Unmarshal([]byte(request), &detail); err != nil {
		return nil, err
	}
	req := &model.UserRequest{
		ID:           cuid.New(),
		CollectionID: collectionID,
		UserUID:      user.UID,
		Type:         model.REST,
		Title:        title,
		Request:      detail,
		OrderIndex:   latest + 1,
	}
	if err := r.DB.Create(req).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(req, "id=?", req.ID).Error; err != nil {
		return nil, err
	}
	UserRequestCreatedSub.Publish(req)
	return req, nil
}

func (r *mutationResolver) CreateGQLUserRequest(ctx context.Context, collectionID string, title string, request string) (*model.UserRequest, error) {
	// panic(fmt.Errorf("not implemented: CreateGQLUserRequest - createGQLUserRequest"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	latest := getUserMaxOrderIndex(r.DB, &model.UserRequest{}, user.UID, &collectionID)
	detail := model.ReqDetail{}
	if err := json.Unmarshal([]byte(request), &detail); err != nil {
		return nil, err
	}
	req := &model.UserRequest{
		ID:           cuid.New(),
		CollectionID: collectionID,
		UserUID:      user.UID,
		Type:         model.GQL,
		Title:        title,
		Request:      detail,
		OrderIndex:   latest + 1,
	}
	if err := r.DB.Create(req).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(req, "id=?", req.ID).Error; err != nil {
		return nil, err
	}
	UserRequestCreatedSub.Publish(req)
	return req, nil
}

func (r *mutationResolver) UpdateRESTUserRequest(ctx context.Context, id string, title *string, request *string) (*model.UserRequest, error) {
	// panic(fmt.Errorf("not implemented: UpdateRESTUserRequest - updateRESTUserRequest"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	req := &model.UserRequest{}
	if err := GetPreloadedDB(r.DB, ctx).First(req, `id=? AND "userUid" = ?`, id, user.UID).Error; err != nil {
		return nil, err
	}
	if title != nil {
		req.Title = *title
	}
	if request != nil {
		detail := model.ReqDetail{}
		if err := json.Unmarshal([]byte(*request), &detail); err != nil {
			return nil, err
		}
		req.Request = detail
	}
	if err := r.DB.Save(req).Error; err != nil {
		return nil, err
	}
	UserRequestUpdatedSub.Publish(req)
	return req, nil
}

func (r *mutationResolver) UpdateGQLUserRequest(ctx context.Context, id string, title *string, request *string) (*model.UserRequest, error) {
	// panic(fmt.Errorf("not implemented: UpdateGQLUserRequest - updateGQLUserRequest"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	req := &model.UserRequest{}
	if err := GetPreloadedDB(r.DB, ctx).First(req, `id=? AND "userUid" = ?`, id, user.UID).Error; err != nil {
		return nil, err
	}
	if title != nil {
		req.Title = *title
	}
	if request != nil {
		detail := model.ReqDetail{}
		if err := json.Unmarshal([]byte(*request), &detail); err != nil {
			return nil, err
		}
		req.Request = detail
	}
	if err := r.DB.Save(req).Error; err != nil {
		return nil, err
	}
	UserRequestUpdatedSub.Publish(req)
	return req, nil
}

func (r *mutationResolver) DeleteUserRequest(ctx context.Context, id string) (bool, error) {
	// panic(fmt.Errorf("not implemented: DeleteUserRequest - deleteUserRequest"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return false, ex.ErrBugAuthNoUserCtx
	}
	req := &model.UserRequest{}
	if err := r.DB.First(req, `id=? AND "userUid" = ?`, id, user.UID).Error; err != nil {
		return false, err
	}
	if err := r.DB.Delete(req).Error; err != nil {
		return false, err
	}
	UserRequestDeletedSub.Publish(req)
	return true, nil
}

func (r *mutationResolver) MoveUserRequest(ctx context.Context, sourceCollectionID string, requestID string, destinationCollectionID string, nextRequestID *string) (*model.UserRequest, error) {
	// panic(fmt.Errorf("not implemented: MoveUserRequest - moveUserRequest"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	dto, err := moveUserRequest(r.DB, user.UID, sourceCollectionID, requestID, destinationCollectionID, nextRequestID)
	if err != nil {
		return nil, err
	}
	err = GetPreloadedDB(r.DB, ctx).Where(`"userUid" = ?`, user.UID).First(dto.Request, "id=?", requestID).Error
	return dto.Request, err
}

func (r *mutationResolver) CreateRESTRootUserCollection(ctx context.Context, title string, data *string) (*model.UserCollection, error) {
	// panic(fmt.Errorf("not implemented: CreateRESTRootUserCollection - createRESTRootUserCollection"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	latest := getUserMaxOrderIndex(r.DB, &model.UserCollection{}, user.UID, nil)
	coll := &model.UserCollection{
		ID:         cuid.New(),
		ParentID:   nil,
		UserUID:    user.UID,
		Title:      title,
		OrderIndex: latest + 1,
		Type:       model.REST,
		Data:       data,
	}
	if err := r.DB.Create(coll).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(coll, "id=?", coll.ID).Error; err != nil {
		return nil, err
	}
	UserCollectionCreatedSub.Publish(coll)
	return coll, nil
}

func (r *mutationResolver) CreateGQLRootUserCollection(ctx context.Context, title string, data *string) (*model.UserCollection, error) {
	// panic(fmt.Errorf("not implemented: CreateGQLRootUserCollection - createGQLRootUserCollection"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	latest := getUserMaxOrderIndex(r.DB, &model.UserCollection{}, user.UID, nil)
	coll := &model.UserCollection{
		ID:         cuid.New(),
		ParentID:   nil,
		UserUID:    user.UID,
		Title:      title,
		OrderIndex: latest + 1,
		Type:       model.GQL,
		Data:       data,
	}
	if err := r.DB.Create(coll).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(coll, "id=?", coll.ID).Error; err != nil {
		return nil, err
	}
	UserCollectionCreatedSub.Publish(coll)
	return coll, nil
}

func (r *mutationResolver) CreateGQLChildUserCollection(ctx context.Context, title string, parentUserCollectionID string, data *string) (*model.UserCollection, error) {
	// panic(fmt.Errorf("not implemented: CreateGQLChildUserCollection - createGQLChildUserCollection"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	latest := getUserMaxOrderIndex(r.DB, &model.UserCollection{}, user.UID, &parentUserCollectionID)
	coll := &model.UserCollection{
		ID:         cuid.New(),
		ParentID:   &parentUserCollectionID,
		UserUID:    user.UID,
		Title:      title,
		OrderIndex: latest + 1,
		Type:       model.GQL,
		Data:       data,
	}
	if err := r.DB.Create(coll).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(coll, "id=?", coll.ID).Error; err != nil {
		return nil, err
	}
	UserCollectionCreatedSub.Publish(coll)
	return coll, nil
}

func (r *mutationResolver) CreateRESTChildUserCollection(ctx context.Context, title string, parentUserCollectionID string, data *string) (*model.UserCollection, error) {
	// panic(fmt.Errorf("not implemented: CreateRESTChildUserCollection - createRESTChildUserCollection"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	latest := getUserMaxOrderIndex(r.DB, &model.UserCollection{}, user.UID, &parentUserCollectionID)
	coll := &model.UserCollection{
		ID:         cuid.New(),
		ParentID:   &parentUserCollectionID,
		UserUID:    user.UID,
		Title:      title,
		OrderIndex: latest + 1,
		Type:       model.REST,
		Data:       data,
	}
	if err := r.DB.Create(coll).Error; err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(coll, "id=?", coll.ID).Error; err != nil {
		return nil, err
	}
	UserCollectionCreatedSub.Publish(coll)
	return coll, nil
}

func (r *mutationResolver) RenameUserCollection(ctx context.Context, userCollectionID string, newTitle string) (*model.UserCollection, error) {
	// panic(fmt.Errorf("not implemented: RenameUserCollection - renameUserCollection"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	coll := &model.UserCollection{}
	if err := GetPreloadedDB(r.DB, ctx).Where(`id = ? AND "userUid" = ?`, userCollectionID, user.UID).First(coll).Error; err != nil {
		return nil, err
	}
	coll.Title = newTitle
	if err := r.DB.Save(coll).Error; err != nil {
		return nil, err
	}
	UserCollectionUpdatedSub.Publish(coll)
	return coll, nil
}

func (r *mutationResolver) DeleteUserCollection(ctx context.Context, userCollectionID string) (bool, error) {
	// panic(fmt.Errorf("not implemented: DeleteUserCollection - deleteUserCollection"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return false, ex.ErrBugAuthNoUserCtx
	}
	coll := &model.UserCollection{}
	if err := r.DB.Where(`id = ? AND "userUid" = ?`, userCollectionID, user.UID).First(coll).Error; err != nil {
		return false, err
	}
	if err := r.DB.Delete(coll).Error; err != nil {
		return false, err
	}
	UserCollectionRemovedSub.Publish(&dto.UserCollectionRemovedData{
		ID:   coll.ID,
		Type: coll.Type,
	})
	return true, nil
}

func (r *mutationResolver) MoveUserCollection(ctx context.Context, destCollectionID *string, userCollectionID string) (*model.UserCollection, error) {
	// panic(fmt.Errorf("not implemented: MoveUserCollection - moveUserCollection"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	coll := &model.UserCollection{}
	if err := r.DB.First(coll, `"userUid"=? AND id=?`, user.UID, userCollectionID).Error; err != nil {
		return nil, err
	}
	if err := moveUserCollection(r.DB, coll, destCollectionID); err != nil {
		return nil, err
	}
	if err := GetPreloadedDB(r.DB, ctx).First(coll, "id=?", coll.ID).Error; err != nil {
		return nil, err
	}
	UserCollectionMovedSub.Publish(coll)
	return coll, nil
}

func (r *mutationResolver) UpdateUserCollectionOrder(ctx context.Context, collectionID string, nextCollectionID *string) (bool, error) {
	// panic(fmt.Errorf("not implemented: UpdateUserCollectionOrder - updateUserCollectionOrder"))
	coll := &model.UserCollection{}
	nextColl := &model.UserCollection{}
	if err := r.DB.First(coll, "id=?", collectionID).Error; err != nil {
		return false, err
	}
	if nextCollectionID != nil {
		if err := r.DB.First(nextColl, "id=?", *nextCollectionID).Error; err != nil {
			return false, err
		}
	} else {
		return false, fmt.Errorf("nextCollectionID is nil")
	}

	tx := r.DB.Begin()
	if coll.OrderIndex > nextColl.OrderIndex {
		if err := tx.Model(coll).Where(`"parentID"=?`, nextColl.ParentID).Where(`"orderIndex">=?`, nextColl.OrderIndex).Where(`"orderIndex"<?`, coll.OrderIndex).Update(`"orderIndex"`, gorm.Expr(`"orderIndex" - 1`)).Error; err != nil {
			tx.Rollback()
			return false, err
		}
		coll.OrderIndex = nextColl.OrderIndex
		if err := tx.Save(coll).Error; err != nil {
			tx.Rollback()
			return false, err
		}
	} else {
		if err := tx.Model(coll).Where(`"parentID"=?`, nextColl.ParentID).Where(`"orderIndex">?`, coll.OrderIndex).Where(`"orderIndex"<=?`, nextColl.OrderIndex).Update(`"orderIndex"`, gorm.Expr(`"orderIndex" - 1`)).Error; err != nil {
			tx.Rollback()
			return false, err
		}
		coll.OrderIndex = nextColl.OrderIndex
		if err := tx.Save(coll).Error; err != nil {
			tx.Rollback()
			return false, err
		}
	}
	tx.Commit()
	UserCollectionMovedSub.Publish(coll)
	return true, nil
}

func (r *mutationResolver) ImportUserCollectionsFromJSON(ctx context.Context, jsonString string, reqType model.ReqType, parentCollectionID *string) (bool, error) {
	panic(fmt.Errorf("not implemented: ImportUserCollectionsFromJSON - importUserCollectionsFromJSON"))
}

func (r *mutationResolver) UpdateUserCollection(ctx context.Context, userCollectionID string, newTitle *string, data *string) (*model.UserCollection, error) {
	// panic(fmt.Errorf("not implemented: UpdateUserCollection - updateUserCollection"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	coll := &model.UserCollection{}
	if err := GetPreloadedDB(r.DB, ctx).First(coll, `"userUiid"=? AND id=?`, user.UID, userCollectionID).Error; err != nil {
		return nil, err
	}
	if newTitle != nil {
		coll.Title = *newTitle
	}
	if data != nil {
		coll.Data = data
	}
	if err := r.DB.Save(coll).Error; err != nil {
		return nil, err
	}
	UserCollectionUpdatedSub.Publish(coll)
	return coll, nil
}

func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// panic(fmt.Errorf("not implemented: Me - me"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}

	val := reflect.ValueOf(user).Elem()
	fields := []string{}
	for i := 0; i < val.NumField(); i++ {
		fields = append(fields, val.Type().Field(i).Name)
	}

	err := GetPreloadedDB(r.DB, ctx, fields...).First(user, "uid=?", user.UID).Error
	return user, err
}

func (r *queryResolver) Infra(ctx context.Context) (*dto.Infra, error) {
	panic(fmt.Errorf("not implemented: Infra - infra"))
}

func (r *queryResolver) InfraConfigs(ctx context.Context, configNames []dto.InfraConfigEnum) (c []*model.InfraConfig, err error) {
	// panic(fmt.Errorf("not implemented: InfraConfigs - infraConfigs"))
	names := []string{}
	for _, name := range configNames {
		names = append(names, name.String())
	}
	err = r.DB.Find(&c, "name in (?)", names).Error
	return
}

func (r *queryResolver) AllowedAuthProviders(ctx context.Context) ([]string, error) {
	// panic(fmt.Errorf("not implemented: AllowedAuthProviders - allowedAuthProviders"))
	providers := strings.Split(os.Getenv("VITE_ALLOWED_AUTH_PROVIDERS"), ",")
	return providers, nil
}

func (r *queryResolver) Admin(ctx context.Context) (*dto.Admin, error) {
	// panic(fmt.Errorf("not implemented: Admin - admin"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	return &dto.Admin{
		UID:         user.UID,
		DisplayName: user.DisplayName,
		Email:       user.Email,
		PhotoURL:    user.PhotoURL,
		CreatedOn:   user.CreatedOn,
	}, nil
}

func (r *queryResolver) MyTeams(ctx context.Context, cursor *string) (t []*model.Team, err error) {
	// panic(fmt.Errorf("not implemented: MyTeams - myTeams"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	member := &[]*model.TeamMember{}
	if err := r.DB.Find(member, `"userUid" = ?`, user.UID).Error; err != nil {
		return nil, err
	}
	team_ids := []string{}
	for _, m := range *member {
		team_ids = append(team_ids, m.TeamID)
	}
	err = GetPreloadedDB(r.DB, ctx).Find(&t, "id in (?)", team_ids).Error
	return
}

func (r *queryResolver) Team(ctx context.Context, teamID string) (*model.Team, error) {
	// panic(fmt.Errorf("not implemented: Team - team"))
	val := reflect.ValueOf(&model.Team{}).Elem()
	fields := []string{}
	for i := 0; i < val.NumField(); i++ {
		fields = append(fields, val.Type().Field(i).Name)
	}
	team := &model.Team{}
	err := GetPreloadedDB(r.DB, ctx, fields...).First(team, "id = ?", teamID).Error
	if err != nil {
		return nil, err
	}
	return team, nil
}

func (r *queryResolver) TeamInvitation(ctx context.Context, inviteID string) (i *model.TeamInvitation, err error) {
	// panic(fmt.Errorf("not implemented: TeamInvitation - teamInvitation"))
	err = GetPreloadedDB(r.DB, ctx).Find(&i, "id = ?", inviteID).Error
	return
}

func (r *queryResolver) ExportCollectionsToJSON(ctx context.Context, teamID string) (string, error) {
	// panic(fmt.Errorf("not implemented: ExportCollectionsToJSON - exportCollectionsToJSON"))
	c := []model.TeamCollection{}
	if err := r.DB.Preload("Team").Preload("Children").Preload("Requests").Preload("Children.Requests").Find(&c, "\"teamID\" = ? AND \"parentID\" IS NULL", teamID).Error; err != nil {
		return "", err
	}
	res := []dto.TeamCollectionExportJSON{}
	for _, coll := range c {
		res = append(res, TeamCollectionToDTO(coll))
	}
	result, err := json.Marshal(res)
	return string(result), err
}

func (r *queryResolver) RootCollectionsOfTeam(ctx context.Context, cursor *string, take *int, teamID string) (c []*model.TeamCollection, err error) {
	// panic(fmt.Errorf("not implemented: RootCollectionsOfTeam - rootCollectionsOfTeam"))
	base := GetPreloadedDB(r.DB, ctx)
	if cursor != nil {
		base = base.Where("id > ?", *cursor)
	}
	err = base.Limit(getLimit(take)).Find(&c, `"teamID" = ?`, teamID).Error
	return
}

func (r *queryResolver) Collection(ctx context.Context, collectionID string) (c *model.TeamCollection, err error) {
	// panic(fmt.Errorf("not implemented: Collection - collection"))
	err = GetPreloadedDB(r.DB, ctx).First(c, "id = ?", collectionID).Error
	return
}

func (r *queryResolver) SearchForRequest(ctx context.Context, cursor *string, take *int, teamID string, searchTerm string) (req []*model.TeamRequest, err error) {
	// panic(fmt.Errorf("not implemented: SearchForRequest - searchForRequest"))
	base := GetPreloadedDB(r.DB, ctx)
	if cursor != nil {
		base = base.Where("id > ?", *cursor)
	}
	err = base.Limit(getLimit(take)).Find(&req).Error
	return
}

func (r *queryResolver) Request(ctx context.Context, requestID string) (req *model.TeamRequest, err error) {
	// panic(fmt.Errorf("not implemented: Request - request"))
	err = GetPreloadedDB(r.DB, ctx).First(req, "id = ?", requestID).Error
	return
}

func (r *queryResolver) RequestsInCollection(ctx context.Context, cursor *string, take *int, collectionID string) (req []*model.TeamRequest, err error) {
	// panic(fmt.Errorf("not implemented: RequestsInCollection - requestsInCollection"))
	base := GetPreloadedDB(r.DB, ctx)
	if cursor != nil {
		base = base.Where("id > ?", *cursor)
	}
	err = base.Limit(getLimit(take)).Find(&req, `"collectionID" = ?`, collectionID).Error
	return
}

func (r *queryResolver) Shortcode(ctx context.Context, code string) (s *model.Shortcode, err error) {
	// panic(fmt.Errorf("not implemented: Shortcode - shortcode"))
	err = GetPreloadedDB(r.DB, ctx).First(s, "id = ?", code).Error
	return
}

func (r *queryResolver) MyShortcodes(ctx context.Context, cursor *string, take *int) (s []*model.Shortcode, err error) {
	// panic(fmt.Errorf("not implemented: MyShortcodes - myShortcodes"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	base := GetPreloadedDB(r.DB, ctx)
	if cursor != nil {
		base = base.Where("id > ?", *cursor)
	}
	err = base.Limit(getLimit(take)).Find(&s, `"creatorUid" = ?`, user.UID).Error
	return
}

func (r *queryResolver) UserRESTRequests(ctx context.Context, cursor *string, take *int, collectionID *string) (c []*model.UserRequest, err error) {
	// panic(fmt.Errorf("not implemented: UserRESTRequests - userRESTRequests"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	base := GetPreloadedDB(r.DB, ctx).Where(`"collectionID" = ? AND "userUid" = ? AND type = ?`, collectionID, user.UID, model.REST)
	if cursor != nil {
		base = base.Where("id > ?", *cursor)
	}
	err = base.Limit(getLimit(take)).Find(&c).Error
	return
}

func (r *queryResolver) UserGQLRequests(ctx context.Context, cursor *string, take *int, collectionID *string) (c []*model.UserRequest, err error) {
	// panic(fmt.Errorf("not implemented: UserGQLRequests - userGQLRequests"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	base := GetPreloadedDB(r.DB, ctx).Where(`"collectionID" = ? AND "userUid" = ? AND type = ?`, collectionID, user.UID, model.GQL)
	if cursor != nil {
		base = base.Where("id > ?", *cursor)
	}
	err = base.Limit(getLimit(take)).Find(&c).Error
	return
}

func (r *queryResolver) UserRequest(ctx context.Context, id string) (req *model.UserRequest, err error) {
	// panic(fmt.Errorf("not implemented: UserRequest - userRequest"))
	err = GetPreloadedDB(r.DB, ctx).First(req, "id = ?", id).Error
	return
}

func (r *queryResolver) RootRESTUserCollections(ctx context.Context, cursor *string, take *int) (c []*model.UserCollection, err error) {
	// panic(fmt.Errorf("not implemented: RootRESTUserCollections - rootRESTUserCollections"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	base := GetPreloadedDB(r.DB, ctx).Where(`"collectionID" IS NULL AND "userUid" = ? AND type = ?`, user.UID, model.REST)
	if cursor != nil {
		base = base.Where("id > ?", *cursor)
	}
	err = base.Limit(getLimit(take)).Find(&c).Error
	return
}

func (r *queryResolver) RootGQLUserCollections(ctx context.Context, cursor *string, take *int) (c []*model.UserCollection, err error) {
	// panic(fmt.Errorf("not implemented: RootGQLUserCollections - rootGQLUserCollections"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	base := GetPreloadedDB(r.DB, ctx).Where(`"collectionID" IS NULL AND "userUid" = ? AND type = ?`, user.UID, model.GQL)
	if cursor != nil {
		base = base.Where("id > ?", *cursor)
	}
	err = base.Limit(getLimit(take)).Find(&c).Error
	return
}

func (r *queryResolver) UserCollection(ctx context.Context, userCollectionID string) (c *model.UserCollection, err error) {
	// panic(fmt.Errorf("not implemented: UserCollection - userCollection"))
	err = GetPreloadedDB(r.DB, ctx).First(c, "id = ?", userCollectionID).Error
	return
}

func (r *queryResolver) ExportUserCollectionsToJSON(ctx context.Context, collectionID *string, collectionType model.ReqType) (*dto.UserCollectionExportJSONData, error) {
	// panic(fmt.Errorf("not implemented: ExportUserCollectionsToJSON - exportUserCollectionsToJSON"))
	user, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	c := []model.UserCollection{}
	if err := r.DB.Preload("Children").Preload("Requests").Preload("Children.Requests").Find(&c, "\"userUid\" = ? AND \"parentID\" IS NULL", user.UID).Error; err != nil {
		return nil, err
	}
	res := []dto.UserCollectionExportJSON{}
	for _, coll := range c {
		res = append(res, UserCollectionToDTO(coll))
	}
	result, err := json.Marshal(res)
	if err != nil {
		return nil, err
	}
	ret := &dto.UserCollectionExportJSONData{
		ExportedCollection: string(result),
		CollectionType:     collectionType,
	}
	return ret, nil
}

func (r *subscriptionResolver) UserUpdated(ctx context.Context) (<-chan *model.User, error) {
	ch := make(chan *model.User)
	go func() {
		defer close(ch)
		for e := range UserUpdatedSub.Subscribe() {
			ch <- e.(*model.User)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserDeleted(ctx context.Context) (<-chan *model.User, error) {
	ch := make(chan *model.User)
	go func() {
		defer close(ch)
		for e := range UserDeletedSub.Subscribe() {
			ch <- e.(*model.User)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserInvited(ctx context.Context) (<-chan *model.InvitedUser, error) {
	ch := make(chan *model.InvitedUser)
	go func() {
		defer close(ch)
		for e := range UserInvitedSub.Subscribe() {
			ch <- e.(*model.InvitedUser)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamMemberAdded(ctx context.Context, teamID string) (<-chan *model.TeamMember, error) {
	ch := make(chan *model.TeamMember)
	go func() {
		defer close(ch)
		for e := range TeamMemberAddedSub.Subscribe() {
			ch <- e.(*model.TeamMember)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamMemberUpdated(ctx context.Context, teamID string) (<-chan *model.TeamMember, error) {
	ch := make(chan *model.TeamMember)
	go func() {
		defer close(ch)
		for e := range TeamMemberUpdatedSub.Subscribe() {
			ch <- e.(*model.TeamMember)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamMemberRemoved(ctx context.Context, teamID string) (<-chan string, error) {
	ch := make(chan string)
	go func() {
		defer close(ch)
		for e := range TeamMemberRemovedSub.Subscribe() {
			ch <- e.(string)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamInvitationAdded(ctx context.Context, teamID string) (<-chan *model.TeamInvitation, error) {
	ch := make(chan *model.TeamInvitation)
	go func() {
		defer close(ch)
		for e := range TeamInvitationAddedSub.Subscribe() {
			ch <- e.(*model.TeamInvitation)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamInvitationRemoved(ctx context.Context, teamID string) (<-chan string, error) {
	ch := make(chan string)
	go func() {
		defer close(ch)
		for e := range TeamInvitationRemovedSub.Subscribe() {
			ch <- e.(string)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamEnvironmentUpdated(ctx context.Context, teamID string) (<-chan *model.TeamEnvironment, error) {
	ch := make(chan *model.TeamEnvironment)
	go func() {
		defer close(ch)
		for e := range TeamEnvironmentUpdatedSub.Subscribe() {
			ch <- e.(*model.TeamEnvironment)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamEnvironmentCreated(ctx context.Context, teamID string) (<-chan *model.TeamEnvironment, error) {
	ch := make(chan *model.TeamEnvironment)
	go func() {
		defer close(ch)
		for e := range TeamEnvironmentCreatedSub.Subscribe() {
			ch <- e.(*model.TeamEnvironment)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamEnvironmentDeleted(ctx context.Context, teamID string) (<-chan *model.TeamEnvironment, error) {
	ch := make(chan *model.TeamEnvironment)
	go func() {
		defer close(ch)
		for e := range TeamEnvironmentDeletedSub.Subscribe() {
			ch <- e.(*model.TeamEnvironment)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamCollectionAdded(ctx context.Context, teamID string) (<-chan *model.TeamCollection, error) {
	ch := make(chan *model.TeamCollection)
	go func() {
		defer close(ch)
		for e := range TeamCollectionAddedSub.Subscribe() {
			ch <- e.(*model.TeamCollection)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamCollectionUpdated(ctx context.Context, teamID string) (<-chan *model.TeamCollection, error) {
	ch := make(chan *model.TeamCollection)
	go func() {
		defer close(ch)
		for e := range TeamCollectionUpdatedSub.Subscribe() {
			ch <- e.(*model.TeamCollection)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamCollectionRemoved(ctx context.Context, teamID string) (<-chan string, error) {
	ch := make(chan string)
	go func() {
		defer close(ch)
		for e := range TeamCollectionRemovedSub.Subscribe() {
			ch <- e.(string)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamCollectionMoved(ctx context.Context, teamID string) (<-chan *model.TeamCollection, error) {
	ch := make(chan *model.TeamCollection)
	go func() {
		defer close(ch)
		for e := range TeamCollectionMovedSub.Subscribe() {
			ch <- e.(*model.TeamCollection)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) CollectionOrderUpdated(ctx context.Context, teamID string) (<-chan *dto.CollectionReorderData, error) {
	ch := make(chan *dto.CollectionReorderData)
	go func() {
		defer close(ch)
		for e := range CollectionOrderUpdatedSub.Subscribe() {
			ch <- e.(*dto.CollectionReorderData)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamRequestAdded(ctx context.Context, teamID string) (<-chan *model.TeamRequest, error) {
	ch := make(chan *model.TeamRequest)
	go func() {
		defer close(ch)
		for e := range TeamRequestAddedSub.Subscribe() {
			ch <- e.(*model.TeamRequest)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamRequestUpdated(ctx context.Context, teamID string) (<-chan *model.TeamRequest, error) {
	ch := make(chan *model.TeamRequest)
	go func() {
		defer close(ch)
		for e := range TeamRequestUpdatedSub.Subscribe() {
			ch <- e.(*model.TeamRequest)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) TeamRequestDeleted(ctx context.Context, teamID string) (<-chan string, error) {
	ch := make(chan string)
	go func() {
		defer close(ch)
		for e := range TeamRequestDeletedSub.Subscribe() {
			ch <- e.(string)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) RequestOrderUpdated(ctx context.Context, teamID string) (<-chan *dto.RequestReorderData, error) {
	ch := make(chan *dto.RequestReorderData)
	go func() {
		defer close(ch)
		for e := range RequestOrderUpdatedSub.Subscribe() {
			ch <- e.(*dto.RequestReorderData)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) RequestMoved(ctx context.Context, teamID string) (<-chan *model.TeamRequest, error) {
	ch := make(chan *model.TeamRequest)
	go func() {
		defer close(ch)
		for e := range RequestMovedSub.Subscribe() {
			ch <- e.(*model.TeamRequest)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) MyShortcodesCreated(ctx context.Context) (<-chan *model.Shortcode, error) {
	ch := make(chan *model.Shortcode)
	go func() {
		defer close(ch)
		for e := range MyShortcodesCreatedSub.Subscribe() {
			ch <- e.(*model.Shortcode)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) MyShortcodesUpdated(ctx context.Context) (<-chan *model.Shortcode, error) {
	ch := make(chan *model.Shortcode)
	go func() {
		defer close(ch)
		for e := range MyShortcodesUpdatedSub.Subscribe() {
			ch <- e.(*model.Shortcode)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) MyShortcodesRevoked(ctx context.Context) (<-chan *model.Shortcode, error) {
	ch := make(chan *model.Shortcode)
	go func() {
		defer close(ch)
		for e := range MyShortcodesRevokedSub.Subscribe() {
			ch <- e.(*model.Shortcode)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserSettingsCreated(ctx context.Context) (<-chan *model.UserSetting, error) {
	ch := make(chan *model.UserSetting)
	go func() {
		defer close(ch)
		for e := range UserSettingsCreatedSub.Subscribe() {
			ch <- e.(*model.UserSetting)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserSettingsUpdated(ctx context.Context) (<-chan *model.UserSetting, error) {
	ch := make(chan *model.UserSetting)
	go func() {
		defer close(ch)
		for e := range UserSettingsUpdatedSub.Subscribe() {
			ch <- e.(*model.UserSetting)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserEnvironmentCreated(ctx context.Context) (<-chan *model.UserEnvironment, error) {
	ch := make(chan *model.UserEnvironment)
	go func() {
		defer close(ch)
		for e := range UserEnvironmentCreatedSub.Subscribe() {
			ch <- e.(*model.UserEnvironment)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserEnvironmentUpdated(ctx context.Context) (<-chan *model.UserEnvironment, error) {
	ch := make(chan *model.UserEnvironment)
	go func() {
		defer close(ch)
		for e := range UserEnvironmentUpdatedSub.Subscribe() {
			ch <- e.(*model.UserEnvironment)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserEnvironmentDeleted(ctx context.Context) (<-chan *model.UserEnvironment, error) {
	ch := make(chan *model.UserEnvironment)
	go func() {
		defer close(ch)
		for e := range UserEnvironmentDeletedSub.Subscribe() {
			ch <- e.(*model.UserEnvironment)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserEnvironmentDeleteMany(ctx context.Context) (<-chan int, error) {
	ch := make(chan int)
	go func() {
		defer close(ch)
		for e := range UserEnvironmentDeleteManySub.Subscribe() {
			ch <- e.(int)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserHistoryCreated(ctx context.Context) (<-chan *model.UserHistory, error) {
	ch := make(chan *model.UserHistory)
	go func() {
		defer close(ch)
		for e := range UserHistoryCreatedSub.Subscribe() {
			ch <- e.(*model.UserHistory)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserHistoryUpdated(ctx context.Context) (<-chan *model.UserHistory, error) {
	ch := make(chan *model.UserHistory)
	go func() {
		defer close(ch)
		for e := range UserHistoryUpdatedSub.Subscribe() {
			ch <- e.(*model.UserHistory)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserHistoryDeleted(ctx context.Context) (<-chan *model.UserHistory, error) {
	ch := make(chan *model.UserHistory)
	go func() {
		defer close(ch)
		for e := range UserHistoryDeletedSub.Subscribe() {
			ch <- e.(*model.UserHistory)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserHistoryDeletedMany(ctx context.Context) (<-chan *dto.UserHistoryDeletedManyData, error) {
	ch := make(chan *dto.UserHistoryDeletedManyData)
	go func() {
		defer close(ch)
		for e := range UserHistoryDeletedManySub.Subscribe() {
			ch <- e.(*dto.UserHistoryDeletedManyData)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserRequestCreated(ctx context.Context) (<-chan *model.UserRequest, error) {
	ch := make(chan *model.UserRequest)
	go func() {
		defer close(ch)
		for e := range UserRequestCreatedSub.Subscribe() {
			ch <- e.(*model.UserRequest)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserRequestUpdated(ctx context.Context) (<-chan *model.UserRequest, error) {
	ch := make(chan *model.UserRequest)
	go func() {
		defer close(ch)
		for e := range UserRequestUpdatedSub.Subscribe() {
			ch <- e.(*model.UserRequest)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserRequestDeleted(ctx context.Context) (<-chan *model.UserRequest, error) {
	ch := make(chan *model.UserRequest)
	go func() {
		defer close(ch)
		for e := range UserRequestDeletedSub.Subscribe() {
			ch <- e.(*model.UserRequest)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserRequestMoved(ctx context.Context) (<-chan *dto.UserRequestReorderData, error) {
	ch := make(chan *dto.UserRequestReorderData)
	go func() {
		defer close(ch)
		for e := range UserRequestMovedSub.Subscribe() {
			ch <- e.(*dto.UserRequestReorderData)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserCollectionCreated(ctx context.Context) (<-chan *model.UserCollection, error) {
	ch := make(chan *model.UserCollection)
	go func() {
		defer close(ch)
		for e := range UserCollectionCreatedSub.Subscribe() {
			ch <- e.(*model.UserCollection)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserCollectionUpdated(ctx context.Context) (<-chan *model.UserCollection, error) {
	ch := make(chan *model.UserCollection)
	go func() {
		defer close(ch)
		for e := range UserCollectionUpdatedSub.Subscribe() {
			ch <- e.(*model.UserCollection)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserCollectionRemoved(ctx context.Context) (<-chan *dto.UserCollectionRemovedData, error) {
	ch := make(chan *dto.UserCollectionRemovedData)
	go func() {
		defer close(ch)
		for e := range UserCollectionRemovedSub.Subscribe() {
			ch <- e.(*dto.UserCollectionRemovedData)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserCollectionMoved(ctx context.Context) (<-chan *model.UserCollection, error) {
	ch := make(chan *model.UserCollection)
	go func() {
		defer close(ch)
		for e := range UserCollectionMovedSub.Subscribe() {
			ch <- e.(*model.UserCollection)
		}
	}()
	return ch, nil
}

func (r *subscriptionResolver) UserCollectionOrderUpdated(ctx context.Context) (<-chan *dto.UserCollectionReorderData, error) {
	ch := make(chan *dto.UserCollectionReorderData)
	go func() {
		defer close(ch)
		for e := range UserCollectionOrderUpdatedSub.Subscribe() {
			ch <- e.(*dto.UserCollectionReorderData)
		}
	}()
	return ch, nil
}

func (r *teamResolver) TeamMembers(ctx context.Context, obj *model.Team) (m []*model.TeamMember, err error) {
	// panic(fmt.Errorf("not implemented: TeamMembers - teamMembers"))
	err = GetPreloadedDB(r.DB, ctx).Find(&m, `"teamID"=?`, obj.ID).Error
	return
}

func (r *teamResolver) MyRole(ctx context.Context, obj *model.Team) (*model.TeamMemberRole, error) {
	// panic(fmt.Errorf("not implemented: MyRole - myRole"))
	operator, ok := ctx.Value(mw.ContextKey("operator")).(*model.User)
	if !ok {
		return nil, ex.ErrBugAuthNoUserCtx
	}
	member := &model.TeamMember{}
	if err := r.DB.Select("role").First(member, `"teamID"=? AND "userUid"=?`, obj.ID, operator.UID).Error; err != nil {
		return nil, err
	}
	return &member.Role, nil
}

func (r *teamResolver) OwnersCount(ctx context.Context, obj *model.Team) (c int64, err error) {
	// panic(fmt.Errorf("not implemented: OwnersCount - ownersCount"))
	// var count int64
	err = r.DB.Model(&model.TeamMember{}).Where(`"teamID"=? AND role=?`, obj.ID, model.OWNER).Count(&c).Error
	// c = int(count)
	return
}

func (r *teamResolver) EditorsCount(ctx context.Context, obj *model.Team) (c int64, err error) {
	// panic(fmt.Errorf("not implemented: EditorsCount - editorsCount"))
	// var count int64
	err = r.DB.Model(&model.TeamMember{}).Where(`"teamID"=? AND role=?`, obj.ID, model.EDITOR).Count(&c).Error
	// c = int(count)
	return
}

func (r *teamResolver) ViewersCount(ctx context.Context, obj *model.Team) (c int64, err error) {
	// panic(fmt.Errorf("not implemented: ViewersCount - viewersCount"))
	// var count int64
	err = r.DB.Model(&model.TeamMember{}).Where(`"teamID"=? AND role=?`, obj.ID, model.VIEWER).Count(&c).Error
	// c = int(count)
	return
}

func (r *teamResolver) TeamInvitations(ctx context.Context, obj *model.Team) (i []*model.TeamInvitation, err error) {
	// panic(fmt.Errorf("not implemented: TeamInvitations - teamInvitations"))
	err = GetPreloadedDB(r.DB, ctx).Find(&i, `"teamID"=?`, obj.ID).Error
	return
}

func (r *teamResolver) TeamEnvironments(ctx context.Context, obj *model.Team) (e []*model.TeamEnvironment, err error) {
	// panic(fmt.Errorf("not implemented: TeamEnvironments - teamEnvironments"))
	err = GetPreloadedDB(r.DB, ctx).Find(&e, `"teamID"=?`, obj.ID).Error
	return
}

func (r *userResolver) GlobalEnvironments(ctx context.Context, obj *model.User) (e *model.UserEnvironment, err error) {
	// panic(fmt.Errorf("not implemented: GlobalEnvironments - globalEnvironments"))
	err = GetPreloadedDB(r.DB, ctx).First(&e, `"userUid"=? AND "isGlobal" IS True`, obj.UID).Error
	return
}

func (r *userResolver) RESTHistory(ctx context.Context, obj *model.User, cursor *string, take *int) (h []*model.UserHistory, err error) {
	// panic(fmt.Errorf("not implemented: RESTHistory - RESTHistory"))
	base := GetPreloadedDB(r.DB, ctx)
	if cursor != nil {
		base = base.Where("id > ?", *cursor)
	}
	err = base.Limit(getLimit(take)).Find(&h, `"userUid"=? AND "reqType"=?`, obj.UID, model.REST).Error
	return
}

func (r *userResolver) GQLHistory(ctx context.Context, obj *model.User, cursor *string, take *int) (h []*model.UserHistory, err error) {
	// panic(fmt.Errorf("not implemented: GQLHistory - GQLHistory"))
	base := GetPreloadedDB(r.DB, ctx)
	if cursor != nil {
		base = base.Where("id > ?", *cursor)
	}
	err = base.Find(&h, `"userUid"=? AND "reqType"=?`, obj.UID, model.GQL).Error
	return
}

func (r *userCollectionResolver) ChildrenRest(ctx context.Context, obj *model.UserCollection, cursor *string, take *int) ([]*model.UserCollection, error) {
	// panic(fmt.Errorf("not implemented: ChildrenRest - childrenREST"))
	colls := []*model.UserCollection{}
	if err := GetPreloadedDB(r.DB, ctx).Find(&colls, `"parentID"=? AND type=?`, obj.ID, model.REST).Error; err != nil {
		return nil, err
	}
	return colls, nil
}

func (r *userCollectionResolver) ChildrenGql(ctx context.Context, obj *model.UserCollection, cursor *string, take *int) ([]*model.UserCollection, error) {
	// panic(fmt.Errorf("not implemented: ChildrenGql - childrenGQL"))
	colls := []*model.UserCollection{}
	if err := GetPreloadedDB(r.DB, ctx).Find(&colls, `"parentID"=? AND type=?`, obj.ID, model.GQL).Error; err != nil {
		return nil, err
	}
	return colls, nil
}

func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

func (r *Resolver) Team() TeamResolver { return &teamResolver{r} }

func (r *Resolver) User() UserResolver { return &userResolver{r} }

func (r *Resolver) UserCollection() UserCollectionResolver { return &userCollectionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type teamResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type userCollectionResolver struct{ *Resolver }
